// Notification Service for AI Agents
import { AgentConfig } from './config';

export interface NotificationPayload {
  title: string;
  message: string;
  severity: 'info' | 'warning' | 'error' | 'critical';
  timestamp: string;
  agent: string;
  data?: any;
}

export interface NotificationResult {
  success: boolean;
  error?: string;
}

export class NotificationService {
  private config: AgentConfig;

  constructor(config: AgentConfig) {
    this.config = config;
  }

  async sendAlert(payload: NotificationPayload): Promise<NotificationResult[]> {
    const results: NotificationResult[] = [];

    // Send to email if configured
    if (this.config.emailConfig) {
      try {
        const emailResult = await this.sendEmail(payload);
        results.push(emailResult);
      } catch (error) {
        results.push({
          success: false,
          error: `Email failed: ${error}`,
        });
      }
    }

    // Send to Slack if configured
    if (this.config.slackConfig) {
      try {
        const slackResult = await this.sendSlack(payload);
        results.push(slackResult);
      } catch (error) {
        results.push({
          success: false,
          error: `Slack failed: ${error}`,
        });
      }
    }

    // Log to console as fallback
    this.logToConsole(payload);

    return results;
  }

  private async sendEmail(payload: NotificationPayload): Promise<NotificationResult> {
    if (!this.config.emailConfig) {
      return { success: false, error: 'Email not configured' };
    }

    // For production, you'd use a service like SendGrid, AWS SES, or NodeMailer
    // For now, we'll simulate the email sending
    console.log('üìß Email Alert:', {
      to: this.config.emailConfig.recipients,
      subject: `[${payload.severity.toUpperCase()}] ${payload.title}`,
      body: this.formatEmailBody(payload),
    });

    return { success: true };
  }

  private async sendSlack(payload: NotificationPayload): Promise<NotificationResult> {
    if (!this.config.slackConfig) {
      return { success: false, error: 'Slack not configured' };
    }

    const slackMessage = {
      channel: this.config.slackConfig.channel,
      text: `üö® ${payload.title}`,
      attachments: [
        {
          color: this.getSeverityColor(payload.severity),
          title: payload.title,
          text: payload.message,
          fields: [
            {
              title: 'Agent',
              value: payload.agent,
              short: true,
            },
            {
              title: 'Severity',
              value: payload.severity.toUpperCase(),
              short: true,
            },
            {
              title: 'Timestamp',
              value: payload.timestamp,
              short: false,
            },
          ],
          footer: 'BeProductive AI Agents',
          ts: Math.floor(Date.now() / 1000),
        },
      ],
    };

    try {
      const response = await fetch(this.config.slackConfig.webhookUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(slackMessage),
      });

      if (!response.ok) {
        throw new Error(`Slack API error: ${response.status}`);
      }

      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: `Failed to send Slack message: ${error}`,
      };
    }
  }

  private formatEmailBody(payload: NotificationPayload): string {
    return `
BeProductive AI Agent Alert

Title: ${payload.title}
Severity: ${payload.severity.toUpperCase()}
Agent: ${payload.agent}
Timestamp: ${payload.timestamp}

Message:
${payload.message}

${payload.data ? `
Data:
${JSON.stringify(payload.data, null, 2)}
` : ''}

---
This alert was generated by the BeProductive AI Monitoring System.
    `.trim();
  }

  private getSeverityColor(severity: string): string {
    switch (severity) {
      case 'critical':
        return 'danger';
      case 'error':
        return 'warning';
      case 'warning':
        return 'warning';
      default:
        return 'good';
    }
  }

  private logToConsole(payload: NotificationPayload): void {
    const emoji = this.getSeverityEmoji(payload.severity);
    console.log(`${emoji} [${payload.agent}] ${payload.title}`, {
      severity: payload.severity,
      message: payload.message,
      timestamp: payload.timestamp,
      data: payload.data,
    });
  }

  private getSeverityEmoji(severity: string): string {
    switch (severity) {
      case 'critical':
        return 'üî•';
      case 'error':
        return '‚ùå';
      case 'warning':
        return '‚ö†Ô∏è';
      default:
        return '‚ÑπÔ∏è';
    }
  }

  // Quick notification methods
  async sendInfo(agent: string, title: string, message: string, data?: any): Promise<NotificationResult[]> {
    return this.sendAlert({
      title,
      message,
      severity: 'info',
      timestamp: new Date().toISOString(),
      agent,
      data,
    });
  }

  async sendWarning(agent: string, title: string, message: string, data?: any): Promise<NotificationResult[]> {
    return this.sendAlert({
      title,
      message,
      severity: 'warning',
      timestamp: new Date().toISOString(),
      agent,
      data,
    });
  }

  async sendError(agent: string, title: string, message: string, data?: any): Promise<NotificationResult[]> {
    return this.sendAlert({
      title,
      message,
      severity: 'error',
      timestamp: new Date().toISOString(),
      agent,
      data,
    });
  }

  async sendCritical(agent: string, title: string, message: string, data?: any): Promise<NotificationResult[]> {
    return this.sendAlert({
      title,
      message,
      severity: 'critical',
      timestamp: new Date().toISOString(),
      agent,
      data,
    });
  }
}