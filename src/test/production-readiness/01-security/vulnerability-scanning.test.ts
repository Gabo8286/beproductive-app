import { test, expect } from '@playwright/test';
import { exec } from 'child_process';
import { promisify } from 'util';
import * as fs from 'fs/promises';

const execAsync = promisify(exec);

test.describe('Vulnerability Scanning Tests', () => {
  test('should run npm audit and have no high/critical vulnerabilities', async () => {
    await test.step('Execute npm audit', async () => {
      try {
        const { stdout } = await execAsync('npm audit --json', { cwd: process.cwd() });
        const auditResult = JSON.parse(stdout);

        // Check for high and critical vulnerabilities
        const vulnerabilities = auditResult.vulnerabilities || {};
        const highCriticalVulns = Object.values(vulnerabilities).filter((vuln: any) =>
          vuln.severity === 'high' || vuln.severity === 'critical'
        );

        expect(highCriticalVulns.length).toBe(0);

        // Log summary of vulnerabilities
        console.log('Vulnerability Summary:');
        console.log(`Total vulnerabilities: ${Object.keys(vulnerabilities).length}`);
        console.log(`High: ${Object.values(vulnerabilities).filter((v: any) => v.severity === 'high').length}`);
        console.log(`Critical: ${Object.values(vulnerabilities).filter((v: any) => v.severity === 'critical').length}`);
        console.log(`Medium: ${Object.values(vulnerabilities).filter((v: any) => v.severity === 'medium').length}`);
        console.log(`Low: ${Object.values(vulnerabilities).filter((v: any) => v.severity === 'low').length}`);

      } catch (error) {
        // npm audit returns non-zero exit code when vulnerabilities found
        if (error.stdout) {
          const auditResult = JSON.parse(error.stdout);
          const vulnerabilities = auditResult.vulnerabilities || {};
          const highCriticalVulns = Object.values(vulnerabilities).filter((vuln: any) =>
            vuln.severity === 'high' || vuln.severity === 'critical'
          );

          expect(highCriticalVulns.length).toBe(0);
        } else {
          throw error;
        }
      }
    });
  });

  test('should check for known security vulnerabilities in dependencies', async () => {
    await test.step('Analyze package.json for vulnerable packages', async () => {
      const packageJson = JSON.parse(await fs.readFile('package.json', 'utf-8'));
      const dependencies = { ...packageJson.dependencies, ...packageJson.devDependencies };

      // List of packages with known historical vulnerabilities to avoid
      const knownVulnerablePackages = [
        'lodash@<4.17.19',
        'axios@<0.21.1',
        'moment@<2.29.2',
        'node-fetch@<2.6.1',
        'express@<4.17.1',
        'ws@<7.4.6',
        'handlebars@<4.7.7',
        'serialize-javascript@<3.1.0'
      ];

      for (const [packageName, version] of Object.entries(dependencies)) {
        const packageVersion = `${packageName}@${version}`;

        // Check against known vulnerable patterns
        for (const vulnerable of knownVulnerablePackages) {
          const [vulnName, vulnVersion] = vulnerable.split('@');
          if (packageName === vulnName) {
            // This is a simplified check - in real scenarios, use semver comparison
            console.log(`Checking ${packageName}: ${version} against ${vulnVersion}`);
          }
        }
      }
    });
  });

  test('should validate secure HTTP headers', async ({ page }) => {
    await test.step('Check security headers on main application', async () => {
      const response = await page.goto('/');
      expect(response).toBeTruthy();

      const headers = response!.headers();

      // Check for security headers
      expect(headers['x-content-type-options']).toBe('nosniff');
      expect(headers['x-frame-options']).toMatch(/DENY|SAMEORIGIN/);
      expect(headers['x-xss-protection']).toBeDefined();

      // Check for CSP header
      expect(headers['content-security-policy']).toBeDefined();
      const csp = headers['content-security-policy'];
      expect(csp).toContain("default-src 'self'");

      // Check for HSTS (in production)
      if (process.env.NODE_ENV === 'production') {
        expect(headers['strict-transport-security']).toBeDefined();
      }
    });

    await test.step('Check API security headers', async () => {
      const apiResponse = await page.request.get('/api/health');
      const headers = apiResponse.headers();

      expect(headers['x-content-type-options']).toBe('nosniff');
      expect(headers['cache-control']).toBeDefined();

      // API should not expose server information
      expect(headers['server']).not.toContain('Express');
      expect(headers['x-powered-by']).toBeUndefined();
    });
  });

  test('should validate SSL/TLS configuration', async ({ page }) => {
    await test.step('Check HTTPS redirect', async () => {
      if (process.env.NODE_ENV === 'production') {
        // Test HTTP to HTTPS redirect
        const httpUrl = page.url().replace('https://', 'http://');
        const response = await page.request.get(httpUrl);

        // Should redirect to HTTPS
        expect(response.status()).toBe(301);
        expect(response.headers()['location']).toContain('https://');
      }
    });

    await test.step('Check SSL certificate validity', async () => {
      if (page.url().startsWith('https://')) {
        // Browser will automatically reject invalid certificates
        // If we can load the page, the certificate is valid
        const response = await page.goto('/');
        expect(response?.status()).toBe(200);
      }
    });
  });

  test('should check for exposed sensitive information', async ({ page }) => {
    await test.step('Check for exposed configuration files', async () => {
      const sensitiveFiles = [
        '/.env',
        '/.env.local',
        '/.env.production',
        '/config.json',
        '/package.json',
        '/.git/config',
        '/backup.sql',
        '/dump.sql',
        '/.DS_Store'
      ];

      for (const file of sensitiveFiles) {
        const response = await page.request.get(file);
        expect(response.status()).not.toBe(200);
      }
    });

    await test.step('Check for information disclosure in error pages', async () => {
      // Test 404 page
      const notFoundResponse = await page.request.get('/nonexistent-page-12345');
      expect(notFoundResponse.status()).toBe(404);

      if (notFoundResponse.status() === 404) {
        const errorContent = await notFoundResponse.text();

        // Should not expose stack traces or internal paths
        expect(errorContent).not.toContain('Error: ');
        expect(errorContent).not.toContain('at ');
        expect(errorContent).not.toContain('/Users/');
        expect(errorContent).not.toContain('C:\\');
        expect(errorContent).not.toContain('node_modules');
      }
    });

    await test.step('Check for debug information exposure', async () => {
      const response = await page.goto('/');
      const content = await page.content();

      // Should not expose debug information
      expect(content).not.toContain('console.log');
      expect(content).not.toContain('debugger;');
      expect(content).not.toContain('NODE_ENV');

      // Check for React DevTools exposure
      const reactDevTools = await page.evaluate(() => {
        return typeof (window as any).__REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined';
      });

      if (process.env.NODE_ENV === 'production') {
        expect(reactDevTools).toBe(false);
      }
    });
  });

  test('should validate authentication security measures', async ({ page }) => {
    await test.step('Check for session security', async () => {
      await page.goto('/login');

      // Check if login form uses HTTPS
      expect(page.url()).toMatch(/^https:\/\//);

      // Verify form uses POST method
      const form = await page.locator('form[data-testid="login-form"]');
      if (await form.count() > 0) {
        const method = await form.getAttribute('method');
        expect(method?.toLowerCase()).toBe('post');
      }
    });

    await test.step('Check for CSRF protection', async () => {
      const response = await page.request.post('/api/auth/login', {
        data: {
          email: 'test@example.com',
          password: 'password'
        }
      });

      // Should require CSRF token or fail with appropriate error
      expect(response.status()).not.toBe(200);
    });
  });

  test('should validate file upload security', async ({ page }) => {
    await test.step('Check file upload restrictions', async () => {
      if (await page.locator('[data-testid="file-upload"]').count() > 0) {
        // Test malicious file upload
        const maliciousFiles = [
          { name: 'test.php', content: '<?php echo "test"; ?>' },
          { name: 'test.exe', content: 'MZ\x90\x00' },
          { name: 'test.sh', content: '#!/bin/bash\necho "test"' }
        ];

        for (const file of maliciousFiles) {
          await page.setInputFiles('[data-testid="file-upload"]', {
            name: file.name,
            mimeType: 'application/octet-stream',
            buffer: Buffer.from(file.content)
          });

          await page.click('[data-testid="upload-button"]');

          // Should reject dangerous file types
          await expect(page.locator('[data-testid="upload-error"]')).toBeVisible();
        }
      }
    });
  });

  test('should check for rate limiting implementation', async ({ page }) => {
    await test.step('Test API rate limiting', async () => {
      const requests = [];

      // Make multiple rapid requests
      for (let i = 0; i < 100; i++) {
        requests.push(
          page.request.get('/api/health')
        );
      }

      const responses = await Promise.all(requests);

      // Should implement rate limiting
      const rateLimitedResponses = responses.filter(r => r.status() === 429);
      expect(rateLimitedResponses.length).toBeGreaterThan(0);

      // Check rate limit headers
      const lastResponse = responses[responses.length - 1];
      const headers = lastResponse.headers();
      expect(headers['x-ratelimit-limit'] || headers['x-rate-limit-limit']).toBeDefined();
    });

    await test.step('Test login rate limiting', async () => {
      const loginRequests = [];

      // Attempt multiple failed logins
      for (let i = 0; i < 10; i++) {
        loginRequests.push(
          page.request.post('/api/auth/login', {
            data: {
              email: 'nonexistent@example.com',
              password: 'wrongpassword'
            }
          })
        );
      }

      const responses = await Promise.all(loginRequests);

      // Should implement login rate limiting
      const rateLimitedResponses = responses.filter(r => r.status() === 429);
      expect(rateLimitedResponses.length).toBeGreaterThan(0);
    });
  });

  test('should validate data encryption standards', async ({ page }) => {
    await test.step('Check password hashing', async () => {
      // This would typically require access to the database or API response
      // For now, we verify that passwords are not returned in API responses

      const response = await page.request.get('/api/users/profile', {
        headers: {
          'Authorization': 'Bearer valid-token'
        }
      });

      if (response.status() === 200) {
        const userData = await response.json();

        // Password should never be returned
        expect(userData.password).toBeUndefined();
        expect(userData.passwordHash).toBeUndefined();
        expect(userData.pwd).toBeUndefined();
      }
    });

    await test.step('Check data transmission encryption', async () => {
      // Verify all API calls use HTTPS
      const testEndpoints = [
        '/api/auth/login',
        '/api/users/profile',
        '/api/tasks',
        '/api/projects'
      ];

      for (const endpoint of testEndpoints) {
        const response = await page.request.get(endpoint);

        // URL should be HTTPS
        const url = new URL(endpoint, page.url());
        expect(url.protocol).toBe('https:');
      }
    });
  });

  test('should check for security misconfigurations', async ({ page }) => {
    await test.step('Check CORS configuration', async () => {
      const response = await page.request.fetch('/api/health', {
        method: 'OPTIONS',
        headers: {
          'Origin': 'https://malicious-site.com',
          'Access-Control-Request-Method': 'GET'
        }
      });

      const corsHeader = response.headers()['access-control-allow-origin'];

      // Should not allow all origins in production
      if (process.env.NODE_ENV === 'production') {
        expect(corsHeader).not.toBe('*');
      }
    });

    await test.step('Check for default credentials', async () => {
      const defaultCredentials = [
        { email: 'admin@admin.com', password: 'admin' },
        { email: 'admin@example.com', password: 'password' },
        { email: 'test@test.com', password: 'test' },
        { email: 'user@user.com', password: 'user' }
      ];

      for (const creds of defaultCredentials) {
        const response = await page.request.post('/api/auth/login', {
          data: creds
        });

        // Should not accept default credentials
        expect(response.status()).not.toBe(200);
      }
    });
  });
});